import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Scanner;

public class HashBased {

	/**
	 * @param args
	 */
	static String FILE_NAME_1 = "data_R.txt";
	static String FILE_NAME_2 = "data_S.txt";

	static int BLOCK_SIZE = 4096;
	static int M;

	static boolean is_R_Lower;
	
	public static void main(String[] args) throws IOException {
		//delete bucktes generated by phase one(if any) 
		deleteSublists("R");
		deleteSublists("S");
		Scanner keyboard = new Scanner(System.in);
		try {
			System.out.println("Enter Memory Blocks:");
			M = keyboard.nextInt();
			//getting input for file R
			System.out.println("-- For file R--");
			System.out.println("Enter tuple size:");
			int tupleSize1 = keyboard.nextInt();
			System.out.println("Enter start index of joining attribute:");
			int startIndex1 = keyboard.nextInt();
			System.out.println("Enter end index of joining attribute:");
			int endIndex1 = keyboard.nextInt();
			
			//getting input for file R
			System.out.println("-- For file S--");
			System.out.println("Enter tuple size:");
			int tupleSize2 = keyboard.nextInt();
			System.out.println("Enter start index of join attribute:");
			int startIndex2 = keyboard.nextInt();
			System.out.println("Enter end index of join attribute:");
			int endIndex2 = keyboard.nextInt();
			
			long t1=System.currentTimeMillis();
			
			doHashing(FILE_NAME_1, tupleSize1, startIndex1, endIndex1, "R");
			doHashing(FILE_NAME_2, tupleSize2, startIndex2, endIndex2, "S");
			
			File f1 = new File(FILE_NAME_1);
			File f2 = new File(FILE_NAME_2);
			
			//select the relation with less tuples;coz its sublist will be kept permanently in main memory
			if (f1.length() < f2.length()) 
				is_R_Lower = true;
			else
				is_R_Lower = false;
			
			int tuplesPerBlockFile1 = (int) Math.ceil((double) BLOCK_SIZE/ tupleSize1);
			int tuplesPerBlockFile2 = (int) Math.ceil((double) BLOCK_SIZE/ tupleSize2);
			
			//starting phase two;i.e. joining Ri & Si
			startJoin(tuplesPerBlockFile1, tuplesPerBlockFile2,startIndex2,endIndex2,startIndex1,endIndex1);
			System.out.println("Time consume by hasbased-join is: "+ (System.currentTimeMillis()-t1)+" ms");
		} catch (Exception e) {
			e.printStackTrace();
		}
		System.out.println("delete temp files??");
		String ans=keyboard.next();
		
		

	}

	private static void deleteSublists(String string) {
		int i = 0;
		File f;
		try {
			//Thread.sleep(1000);
			while(true){
				 f= new File("hashbased_data_" + string + "_" + (i++) + ".txt");
				
				if (f.exists()){
					f.delete();
					/*while (f.exists()) {
						f.delete();
					}*/
				}
				else 
					break;
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		
	}

	//it will hash all the tuples & generate sublists from 0 to M-1
	public static void doHashing(String filename, int tupple_size,
			int start, int end, String relation) throws IOException {

		int no_of_tuples_per_block = (int) Math.ceil((double) BLOCK_SIZE/ tupple_size);
		
		DataInputStream in = new DataInputStream(new FileInputStream(filename));
		BufferedReader br = new BufferedReader(new InputStreamReader(in));

		String[] input = new String[no_of_tuples_per_block];

		String[][] output = new String[M - 1][no_of_tuples_per_block];

		int[] counterForOutputArray = new int[M - 1];

		for (int i = 0; i < counterForOutputArray.length; i++)
			counterForOutputArray[i] = 0;

		boolean isEOF = false;

		while (!isEOF) {
			int valuesininputArray = 0;
			for (int i = 0; i < no_of_tuples_per_block; i++) {
				String str;
				valuesininputArray = i;
				if ((str = br.readLine()) != null) {
					input[i] = str;
				} else {
					isEOF = true;
					break;
				}
			}

			for (int i = 0; i < valuesininputArray; i++) {
				
				int bucket = calculateHash(input[i], start, end);

				output[bucket][counterForOutputArray[bucket]] = input[i];
				counterForOutputArray[bucket]++;

				if (counterForOutputArray[bucket] == no_of_tuples_per_block) {

					File f = new File("hashbased_data_" + relation + "_" + bucket + ".txt");
					FileWriter fw;
					if (f.exists()) {
						fw = new FileWriter(f, true);
					} else {
						fw = new FileWriter(f, false);
					}
					PrintWriter print = new PrintWriter(fw);

					for (int j = 0; j < no_of_tuples_per_block; j++) {
						print.println(output[bucket][j]);
					}
					print.close();
					fw.close();
					counterForOutputArray[bucket] = 0;
				}

				
				if (isEOF) {
					for (int j = 0; j < M - 1; j++) {
						if (counterForOutputArray[j] < no_of_tuples_per_block) {

							File f = new File("hashbased_data_" + relation+ "_" + j + ".txt");
							FileWriter fw;
							if (f.exists()) {
								fw = new FileWriter(f, true);
							} else {
								fw = new FileWriter(f, false);
							}
							PrintWriter print = new PrintWriter(fw);

							for (int k = 0; k < counterForOutputArray[j]; k++) {
								print.println(output[j][k]);
							}
							counterForOutputArray[j] = 0;
							print.close();

							fw.close();

						}
					}
				}
			}

		}
	}

	//hash function will return result between 0 to M-1
	public static int calculateHash(String tupple, int start, int end) { // 6,10 & 10,14
		int joiningAttribute = Integer.parseInt(tupple.substring(start, end));
		return joiningAttribute % (M - 1);
	}

	public static void startJoin(int tuplesPerBlockForFile1,
		int tuplesPerBlockForFile2, int startS, int endS, int startR, int endR) throws IOException {

		String[] input_R = new String[(M - 1) * tuplesPerBlockForFile1];

		for (int i = 0; i < M-1; i++) {
			String lower_filename = null;
			if (is_R_Lower){
				lower_filename = "hashbased_data_R_" + i + ".txt";
			}else{
				lower_filename = "hashbased_data_S_" + i + ".txt";
			}
			DataInputStream in = new DataInputStream(new FileInputStream(lower_filename));
			BufferedReader br = new BufferedReader(new InputStreamReader(in));

			int counterR = 0;
			String strline;
			while ((strline = br.readLine()) != null) {
				input_R[counterR++] = strline;

			}
			counterR = 0;

			String highe_filename = null;
			if (is_R_Lower){
				highe_filename = "hashbased_data_S_" + i + ".txt";
			}else{
				highe_filename = "hashbased_data_R_" + i + ".txt";
			}
			DataInputStream in_S = new DataInputStream(new FileInputStream(highe_filename));
			BufferedReader br_S = new BufferedReader(
					new InputStreamReader(in_S));

			Boolean isEOF = false;
			while (!isEOF) {
				String[] inputArray_S = new String[tuplesPerBlockForFile2];
				for (int j = 0; j < tuplesPerBlockForFile2; j++) {
					String temp;
					if ((temp = br_S.readLine()) == null) {
						isEOF = true;
						break;
					}

					inputArray_S[j] = temp;
				}
				if (is_R_Lower){
					performJoin(input_R, inputArray_S,startS, endS, startR, endR);
				}else{
					performJoin(input_R, inputArray_S,startR, endR, startS, endS);
				}
				//performJoin(input_R, inputArray_S,startS, endS, startR, endR);

			}

		}
	}

	public static void performJoin(String[] arr1, String[] arr2, int startS, int endS, int startR, int endR) throws IOException {
		
		PrintWriter print = new PrintWriter(new FileWriter("output_hashbased.txt", true));
		for (int i = 0; i < arr2.length; i++) {
			if (arr2[i] == null) break;
			//System.out.println("arr[i]=="+arr1[i].substring(startR, endR));
			int joinValueS = Integer.parseInt(arr2[i].substring(startS, endS));
			for (int j = 0; j < arr1.length; j++) {
				if (arr1[j] == null) break;
				//System.out.println("arr[j]=="+arr1[j].substring(startR, endR));
				int joinValueR = Integer.parseInt(arr1[j].substring(startR,endR));
				//System.out.print(joinValueR);
				if (joinValueS == joinValueR)	
					print.println(arr1[j] + "\t" + arr2[i]);
			}
		}

		print.close();
	}

}
