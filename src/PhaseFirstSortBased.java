

import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Scanner;

public class PhaseFirstSortBased {
	
	static String FILE_NAME_1 = "data_R.txt";
	static String FILE_NAME_2 = "data_S.txt";

	static int BLOCK_SIZE = 4096;
	static int MEM_BLOCK;

	public static void main(String[] args) throws IOException {
		//deleting the sublists generated by phase one to free some memory(if any)
		deleteSublists("R");
		deleteSublists("S");
		Scanner keyboard = new Scanner(System.in);
		try {
			
			System.out.println("Enter Memory Blocks:");
			MEM_BLOCK = keyboard.nextInt();
			//getting input for file one
			System.out.println("-- For file R--");
			System.out.println("Enter tuple size:");
			int tupleSize1 = keyboard.nextInt();
			
			File f = new File (FILE_NAME_1);
			long noOftuples1 = (int) Math.ceil((double)f.length() / tupleSize1);
			int tuplesPerBlock1 = (int)Math.ceil((double)BLOCK_SIZE/tupleSize1);
			int runs_R=(int)Math.ceil((double)noOftuples1/tuplesPerBlock1);
			
			System.out.println("Enter start index of join attribute:");
			int startIndex1 = keyboard.nextInt();
			System.out.println("Enter end index of join attribute:");
			int endIndex1 = keyboard.nextInt();

			//getting input for file two
			System.out.println("-- For file S--");
			System.out.println("Enter tuple size:");
			int tupleSize2 = keyboard.nextInt();
			f = new File (FILE_NAME_2);
			int noOftuples2 = (int) Math.ceil((double)f.length() / tupleSize2);
			int tuplesPerBlock2 = (int)Math.ceil((double)BLOCK_SIZE/tupleSize2);
			int runs_S=(int)Math.ceil((double)noOftuples2/tuplesPerBlock2);
			
			System.out.println("Enter start index of join attribute:");
			int startIndex2 = keyboard.nextInt();
			System.out.println("Enter end index of join attribute:");
			int  endIndex2 = keyboard.nextInt();
			
			long startTime=System.currentTimeMillis();
			
			//running phase one of 2PMMS on both files,to generate sorted sublists
			new PhaseFirstSortBased().generateSublists(FILE_NAME_1,"R",noOftuples1,tupleSize1,startIndex1,endIndex1);
			new PhaseFirstSortBased().generateSublists(FILE_NAME_2,"S",noOftuples2,tupleSize2,startIndex2,endIndex2);
			
			PhaseSecondSortBased t = new PhaseSecondSortBased();
			t.performTwoWay(runs_R, runs_S, tupleSize1, startIndex1, endIndex1, tupleSize2, startIndex2, endIndex2);
			System.out.println("Time consume by sortbased-join is: "+ (System.currentTimeMillis()-startTime)+" ms");

		} catch (Exception e) {
			e.printStackTrace();
		}
		//deleting the sublists generated by phase one to free some memory
		deleteSublists("R");
		deleteSublists("S");	
	}

	private static void deleteSublists(String string) {
		
		int i = 1;
		while(true){
			File f = new File("data_"+string+"_" + (i++) + ".txt");
			if (f.exists()) f.delete();
			else break;
		}
	}
	
	//phase one of 2PMMS
	private void generateSublists(String filename, String suffix, long no_of_tuples, int sizeOfTuple, int start, int end) throws IOException{
		
		
		int tuplesPerBlock = (int)Math.ceil((double)BLOCK_SIZE/sizeOfTuple);
		
		BufferedReader br = new BufferedReader(new InputStreamReader(new DataInputStream(new FileInputStream(filename))));
		FileOperations f = new FileOperations(filename);
		
		SortingHelper s = new SortingHelper();
		 
		int runs=(int)Math.ceil((double)no_of_tuples/tuplesPerBlock);
		
		
		String[] tempStringArr = new String[tuplesPerBlock * MEM_BLOCK];
		
		for (int i = 1; i <= runs; i++) {
			if (i == runs) {
				if (no_of_tuples % (tuplesPerBlock * MEM_BLOCK) != 0)
					tempStringArr = new String[(int) (no_of_tuples % (tuplesPerBlock * MEM_BLOCK))];
				else
					tempStringArr = new String[tuplesPerBlock * MEM_BLOCK];
			} else {
				tempStringArr = new String[tuplesPerBlock * MEM_BLOCK];
			}
			
			int counter = 0;
			for (int j = 0; j < tuplesPerBlock; j++) {
				String strline ;
				if ((strline = br.readLine()) == null) break;
				tempStringArr[j] = strline;	
				counter++;
			}
			//sort the sublist before writing to file
			s.doQuickSort(tempStringArr, 0,counter - 1, start,end);

			f.writeToFile("data_"+suffix+"_" + i + ".txt", tempStringArr);
			
		}
		
		System.gc();
	}
}
